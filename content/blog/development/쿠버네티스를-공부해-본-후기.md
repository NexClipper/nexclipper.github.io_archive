---
title: 쿠버네티스를 공부해 본 후기
date: 2020-01-02 13:01:49
category: development
draft: false
---

### 0. 들어가는 말

---

안녕하세요.
넥스클라우드에서 프론트를 담당하고 있는 Evan이라고 합니다.
오늘은 신년을 맞이해서 가볍게 제가 작년 9월부터 시작해서 12월까지
넥스클라우드에서 프로덕트를 만들고 하면서 모르던 쿠버네티스에 대해서 공부해보고 경험해보았던 것을 정리해보려고 합니다.
정리하는 것들 중에 틀린 부분은 분명히 있을 것이라고 생각합니다.
피드백 주시면 바로 반영하겠습니다.

### 1. 도커

---

전에 서비스를 만들때 Dockerfile까지 구성해본 적은 있어서
대시보드를 구성할 때 프론트의 Dockerfile을 구성해보는 것은 충분히 할만 하였습니다.

그래도 간단하게나만 도커에 대해서 정리해보고 가려고 합니다.

일단 전의 서비스에서 도입하게 된 이유 자체는
제 컴퓨터와 서버의 node, npm 버전이 다르던지
서비스에 종속된 라이브러리들의 버전이 다르면 종종 서버에 배포하였을때 문제가 되는 경우가 발생하였고
이를 해결하기 위해서 찾아보다보니 Docker라는 것이 존재하는 것을 알게 되었습니다.

도커는 컨테이너 기반의 오픈소스 가상화 플랫폼이라고 보통 정리되는데

여기서 컨테이너는 격리된 공간에서 프로세스가 동작하는 기술입니다.

도커를 하시다보면 image를 만든다는 말이 있습니다.
이미지(image)는 컨테이너 실행에 필요한 파일과 설정값 등이 포함되어 있는 것고 상태값을 가지지 않고 변하지 않습니다.

위와 같은 특성 때문에 사실상 쓴다고 봐도 무방하지 않을까 싶습니다.

보통 이 이미지를 만들어서 도커 허브나 클라우드 서비스 상의 레지스트리에 올려서 사용하게 됩니다.

### 2. 쿠버네티스

---

넥스클라우들 들어오기 전까지는 사실 알고 있는 컨테이너 오케스트레이션 도구라고는 도커 스윔밖에 없었고
그마저도 당장 필요하지 않다고 판단되서 공부해본 적이 없었습니다.

그런 저에게 쿠버네티스의 용어들은 하나같이 어려웠습니다.
일단은 그래서 쿠버네티스의 대략적인 개념을 개인 블로그에 정리하면서 익숙해지는 작업을 하였습니다.

다들 아시는 내용이겠지만 대략적으로 제가 쿠버네티스에 대해서 정리해본 내용은 다음과 같습니다.

#### 쿠버네티스의 서버구성

---

쿠버네티스는 Master와 Node로 나눠지며
Master는 쿠버네티스의 클러스터 전체를 관리하는 역할을 담당하고
Node는 컨테이너 애플리케이션을 동작시키는 서버입니다.

#### 쿠버네티스의 리소스

---

쿠버네티스에는 많은 종류의 리소스들이 있습니다.

대략적으로 정리하자면 아래와 같습니다.

**Node**

쿠버네티스의 워커노드의 리소스로써 물리 서버 또는 가상 서버로 구성되게 됩니다.

**Pod**

Pod는 하나 혹은 여러 개의 컨테이너로 이루어져있으며 쿠버네티스에서는 Pod가 어플리케이션의 디플로이 단위가 되게 됩니다.

**ReplicaSet**

ReplicaSet는 클러스터 안에서 지정된 수만큼의 Pod를 작동시키는 장치입니다.

**Deployment**

Deployment는 어플리케이션의 배포 단위를 관리하여 줍니다.

**DaemonSet**

DaemonSet은 각각의 Node에서 반드시 하나씩 작동시키고 싶을 경우 사용하게 됩니다. (감시에이전트 등)

**StatefullSet**

StatefullSet은 Pod의 스케일링을 관리하고 Pod들에 대한 배치와 유일성을 보장해줍니다.

**Service**

Service는 쿠버네티스 클러스터 안에서 실행된 Pod에 대해 엑세스 하는 방법을 제공하여줍니다.

**Ingress**

Ingress는 클러스터 외부의 네트워크로부터 엑세스를 어떻게 처리할지 정리해둔 규칙들의 모읍니다.

**ConfigMap**

ConfigMap은 어플리케이션의 설정 정보, 구성파일, 포트 번호 등을 Pod에서 참조할 수 있도록 해주는 장치입니다.

**Secrets**

Secrets는 aws key 등의 보안이 필요한 정보를 컨테이너 어플리케이션에 전달할 때 사용하는 리소스입니다.

**Job**

하나 또는 여러 개의 Pod에서 처리되는 배치 잡을 실행하기 위한 리소스입니다.

**CronJon**

정해진 타이밍에 반복할 job실행에 사용하는 리소스입니다.

**Namespace**

리소스가 속한 공간입니다.

**ResourceQuota**

Namespace별로 사용하는 리소스 상한을 설정해줍니다.

**PersistentVolume**

신규 Volume의 작성이나 기존 Volume의 삭제 등을 수행하는 리소스입니다.

**PersistentVolumeClaim**

PersistentVolume을 Pod에서 사용하기 위한 리소스입니다.

**NetworkPolicy**

Pod끼리의 통신 가능 여부를 제어하는 리소스입니다.

**ServiceAccount**

Pod와 k8s의 인증을 위한 계정입니다.

**Role/ClusterRole**

어떤 리소스에 어떤 조작을 허가할지를 정의하기 위한 리소스입니다.

**RoleBinding/ClusterRoleBinding**

어떤 Role/ClusterRole을 어떤 사용자/그룹/ServiceAccount와 연결시킬지를 정의하기 위한 리소스입니다.

#### 쿠버네티스의 컴포넌트

---

Master와 Node에는 다양한 컴포넌트로 이루어져 있습니다.

Master의 경우에는 API Server, Scheduler, Controller Manager, etcd로 이루어져 있습니다.

API Server의 경우 쿠버네티스의 리소스 정보를 관리하기 위한 프론트엔드 REST API로
각 컴포넌트로부터 리소스 정보를 받아 데이터스토어(etcd)에 저장하는 역할을 합니다.

Schedule의 경우 Pod를 어느 Node에서 작동시킬지를 제어하기 위한 컴포넌트입니다.

Controller Manager는 쿠버네티스 클러스터의 상태를 감시하고 샅래를 유지시켜주는 컴포넌트입니다.

etcd는 쿠버네티스 클러스터 구성을 유지하는 컴포넌트로 데이터를 Key-Value형으로 관리합니다.

다음으로 Node의 경우에는 kubelet와 kube-proxy로 이루어져 있습니다.

kubelet는 Node의 status를 정기적으로 감시하면서 Pod 정의 파일에 따라 컨테이터를 실행하거나 스토리지를 마운트하는 기능을 가지고 있습니다.

kube-proxy의 경우 다양한 중계 및 변환을 수행하는 네크워크 프록시입니다.

##### 매니페스트 파일

위의 나열한 리소스들을 쿠버네티스에서 어떻게 구성할지에 대해서 매니페스트파일을 통해서 관리하게 됩니다.

```yaml
apiVersion: [API의 버전 정보]
kind: [리소스의 종류]
metadata:
	name: [리소스의 이름]
spec:
[리소스의 상세 정보]
```

쿠버네티스 리소스따라 다르겠지만 보통 매니페스트 파일은 위와 같이 구성되게 됩니다.

### 3. 마치는 말

---

이상으로 제가 공부해 본것들에 대해서 정리해보았습니다.
사실상 아직도 정리만 해보고 AKS, GKE, 회사 서버에만 배포 정도만 해봤을뿐 운용이나 실제 프로덕트에서 해보진 않아서 조금 더 개념 정리가 더 필요한 부분은 분명해보입니다.

부족한 글 읽어주셔서 감사합니다.
